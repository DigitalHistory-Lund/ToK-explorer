---
title: Exploring Baselines
jupyter: tok
execute:
    echo: false
    author:
        - Mathias Johansson
        - Ulrika Holgersson
---



```{python}
# !pip install -q tqdm pyriksdagen ipywidgets plotly
```

```{python}
#| scrolled: true
from pyriksdagen.utils import protocol_iterators, download_corpus

from pathlib import Path
from queue import Queue
from lxml import etree
from tqdm.auto import tqdm

import plotly.offline as pyo
import plotly.graph_objs as go
from typing import List, Tuple

from collections import defaultdict
from collections import Counter
from itertools import pairwise

import sqlite3
import json
import gzip
import csv
import re
import os
```

```{python}
parser = etree.XMLParser(remove_blank_text=True)

data_dir = Path('.').resolve() / 'data'
data_dir.mkdir(exist_ok=True)
```

```{python}
if len([file for file in data_dir.iterdir() if file.is_file()]) < 25:
    print('Did not find metadata files. Downloading.')
    download_corpus(partitions=["persons"])

records_data_dir = data_dir / 'records'
if len([subdir for subdir in data_dir.iterdir() if subdir.is_dir()]) < 158:
    print('Did not find protocols files. Downloading.')
    download_corpus(partitions=["records"])
```

```{python}
#| scrolled: true
def datestr_to_int(date_str):
    """Convert YYYY-MM-DD to an int with all digits"""
    year, mon, day = date_str.split('-')
    if not all((len(date_str) == 10, len(year) == 4, len(mon) == 2, len(day) == 2, year.isdigit(), mon.isdigit(), day.isdigit())):
        raise ValueError(f'{date_str=} does not adhere to "YYYY-MM-DD"')

    no_dashes = date_str.replace('-', '')
    if len(no_dashes) != 8:
        raise ValueError
    return int(no_dashes)
```

```{python}
# Loading utterance to (intified) dates
year_path = Path('.') / 'year_data.gzip'
if not year_path.exists():
    !wget --no-check-certificate 'https://drive.google.com/uc?export=download&id=1n_RzrYH-ghTF0dIV6tY67r_mVZb2ktyd' -O year_data.gzip
with gzip.open(year_path, 'rt') as f:
    id_to_intdate = {_id: datestr_to_int(date) for date, ids in json.loads(f.read()).items() for _id in ids}
```

```{python}
#| scrolled: true
# ID to gender - default to None if there is no data
id_to_gender = defaultdict(lambda: None)
for row in csv.DictReader(open(data_dir/'person.csv')):
    id_to_gender[row['person_id']]= row['gender']
```

```{python}
# Generator for loading party affiliation with intified date ranges.
def load_person_dates_affiliation():
    for row in csv.DictReader(open(data_dir / 'party_affiliation.csv')):
        if row['start'] is None or len(row['start']) == 0:
            start = 0
        elif len(row['start']) == 4:
            start = datestr_to_int(row['start']+'-01-01')
        elif len(row['start']) == 7:
            start = datestr_to_int(row['start']+'-01')
        else:
            start = datestr_to_int(row['start'])
        if row['end'] is None or len(row['end']) == 0:
            end = 99999999
        elif len(row['end']) == 4:
            end = datestr_to_int(row['end'] + '-12-31')
        elif len(row['end']) == 7:
            end = datestr_to_int(row['end'] + '-31') # Since we are not planning on converting these back to actual days, this works.
        else:
            end = datestr_to_int(row['end'])
        yield (row['person_id'], start, end, row['party'])
```

```{python}
protocols = list(sorted(protocol_iterators(corpus_root="data/", start=1899, end=1941)))
print(len(protocols))
```

```{python}
int(protocols[0].split('/')[1][:4])
```

```{python}
def prepare_roots(protocols):
    for protocol in protocols:
        year = int(protocol.split('/')[1][:4])
        yield etree.parse(protocol, parser).getroot(), year
```

```{python}
def process_root_queue(q: Queue):
    """
    TODO: Extract debate names
    TODO: Extract dates
    """
    while not q.empty():
        c, element, year = q.get()
        if (who:= element.get('who')) is not None:
            u_id = element.get([key for key in element.keys() if key.endswith('}id')][0])
            assert u_id
            prev = element.get('prev')
            nxt = element.get('next')

            text = '\n\n'.join(re.sub(r'\s+' ,' ', seg.text) for seg in element.getchildren())
            yield u_id, prev, nxt, text, who, year
        else:
            for child in element.getchildren():
                if (child.tag.endswith('note') or child.tag.endswith('seg')) and not bool(re.search(r'^\S+dag', child.text)):
                    continue
                q.put((c+1, child, year))
```

```{python}
def extract_all_utterances(protocols):
    q = Queue()
    for root, year in prepare_roots(protocols):
        q.put((0,root, year))
    yield from process_root_queue(q)
```

```{python}
from itertools import islice
def batched(iterable, n, *, strict=False):
    # batched('ABCDEFG', 2) â†’ AB CD EF G
    if n < 1:
        raise ValueError('n must be at least one')
    iterator = iter(iterable)
    while batch := tuple(islice(iterator, n)):
        if strict and len(batch) != n:
            raise ValueError('batched(): incomplete batch')
        yield batch
```

```{python}
tmp_db = './tmp.db'
if not os.path.exists(tmp_db):

  all_utterances = list(tqdm(extract_all_utterances(protocols), total=701_218))

  with sqlite3.connect(tmp_db) as conn:
      cur = conn.cursor()
      cur.execute('CREATE TABLE utterance (id str primary key, prev text, next text, who text, year int, date int, gender text, party text)')
      # cur.execute("PRAGMA compile_options LIKE '%SQLITE_ENABLE_FTS5%';")
      cur.execute('CREATE VIRTUAL TABLE utterance_fts USING fts5(id, content)')
      cur.execute('CREATE VIRTUAL TABLE reverse_utterance_fts USING fts5(id, content)')

      cur.execute('CREATE TABLE affiliation (who text, start int, end int, party text)')

      cur.execute('CREATE index next_index on utterance(next)')
      cur.execute('CREATE index prev_index on utterance(prev)')
      cur.execute('CREATE index who_index on utterance(who)')
      cur.execute('CREATE index year_index on utterance(year)')

      cur.executemany('INSERT INTO affiliation (who, start, end, party) values (?,?,?,?)', load_person_dates_affiliation())
      cur.execute('CREATE index aff_index on affiliation(who)')


      data = []
      for batch in tqdm(batched(all_utterances, 50_000), total=len(all_utterances)//50_000):
          data = [
              {'id':u_id,
              'prev':prev,
              'next':nxt,
              'content':text,
              'reverse_content':text[::-1],
              'who':who,
              'year':year,
              'gender': id_to_gender[who],
              'date' : id_to_intdate[u_id]
              } for u_id, prev, nxt, text, who, year in batch]

          cur.executemany('INSERT INTO utterance_fts (id, content) values (:id, :content)', data)
          cur.executemany('INSERT INTO reverse_utterance_fts (id, content) values (:id, :reverse_content)', data)
          cur.executemany('INSERT INTO utterance (id, prev, next, who, year, gender, date) values (:id, :prev, :next, :who, :year, :gender, :date)', data)

          conn.commit()

      cur.execute("""
      UPDATE utterance
      SET party = (
          SELECT party
          FROM affiliation
          WHERE utterance.who = affiliation.who
            AND date BETWEEN start AND end
      )
      WHERE EXISTS (
          SELECT 1
          FROM affiliation
          WHERE utterance.who = affiliation.who
            AND date BETWEEN start AND end
      )
      """)
```

```{python}
def get_baseline():
    with sqlite3.connect(tmp_db) as conn:
        cur = conn.cursor()

        return {x:y for x,y in cur.execute(f'select year, count(*) from utterance as u join utterance_fts as uf on u.rowid == uf.rowid group by year').fetchall()}
baseline = get_baseline()
```

```{python}
def make_line(timeline, name):
    x,y = zip(*timeline)
    total = sum(y)
    name_with_count = f'{name} ({total:,})'
    yy = [y1/baseline[x1] for x1,y1 in timeline]
    assert len(y) == len(yy)
    return go.Scatter(mode='lines', x=x, y=y, name=name_with_count), go.Scatter(mode='lines', x=x, y=yy, name=name_with_count)
```

```{python}
pyo.init_notebook_mode(connected=False)
```

```{python}
def enable_plotly_in_cell():

  import IPython
  from plotly.offline import init_notebook_mode
  display(IPython.core.display.HTML('''<script src="/static/components/requirejs/require.js"></script>'''))
  init_notebook_mode(connected=False)
```

## Establishing baselines

```{python}
with sqlite3.connect(tmp_db) as conn:
    cur = conn.cursor()

    line, r = make_line(cur.execute('select year, count(*) from utterance group by year order by year').fetchall(), 'total')


pyo.iplot({'data' : [line,],
            'layout':{
                'title':{
                    'text': 'Number of utterances per year',
                    'xanchor': 'center',
                    'x':0.5
                }, }})
```

```{python}
with sqlite3.connect(tmp_db) as conn:
    cur = conn.cursor()

    line, r = make_line(cur.execute('select year, sum(length(uf.content)) from utterance as u join utterance_fts as uf on u.rowid == uf.rowid group by year order by year').fetchall(), 'total')

pyo.iplot({'data' : [line],
            'layout':{
                'title':{
                    'text': 'Number of characters per year',
                    'xanchor': 'center',
                    'x':0.5
                }, }})
```

```{python}
with sqlite3.connect(tmp_db) as conn:
    cur = conn.cursor()

    line, r = make_line(cur.execute(
        '''
        select
          year,
          sum(
            length(uf.content) -
            length(
              replace(
                replace(
                  replace(
                    uf.content,
                    " ",
                    ""
                  ),
                  "\t",
                  ""
                ),
              "\n",
              ""
              )
            )
          )
        from
          utterance as u
        join
          utterance_fts as uf
          on
            u.rowid == uf.rowid
        group by
          year
        order by
          year
        ''').fetchall(), 'total')


pyo.iplot({'data' : [line,],
            'layout':{
                'title':{
                    'text': 'Number of words per year',
                    'xanchor': 'center',
                    'x':0.5
                }, }})
```

```{python}
with sqlite3.connect(tmp_db) as conn:
    cur = conn.cursor()

    line, r = make_line(cur.execute('select year, count(distinct who) from utterance group by year order by year').fetchall(), 'total')


pyo.iplot({'data' : [line,],
            'layout':{
                'title':{
                    'text': 'Number of speakers per year',
                    'xanchor': 'center',
                    'x':0.5
                }, }})
```

```{python}
from itertools import pairwise
from collections import defaultdict

def speakers():
  with sqlite3.connect(tmp_db) as conn:
    cur = conn.cursor()

    mapper = defaultdict(int)

    for (year_old, who_old), (year_new, who_new) in pairwise([(None, None)] + list(cur.execute('select year, who from utterance group by year, id order by date').fetchall())):
      if who_old != who_new or year_old != year_new:
        mapper[year_new] += 1

  return sorted(mapper.items())



line, r = make_line(speakers(), 'total')

pyo.iplot({'data' : [line,],
            'layout':{
                'title':{
                    'text': 'Number of cohesive utterances per year',
                    'xanchor': 'center',
                    'x':0.5
                }, }})
```

```{python}
def speechy():
  with sqlite3.connect(tmp_db) as conn:
    cur = conn.cursor()

    for old, new in pairwise([(None,None,None,)] + cur.execute('select year, uf.content, who from utterance as u join utterance_fts as uf on u.rowid == uf.rowid group by year, u.id').fetchall() + [(None,None,None,)]):
      if None in new:
        break
      yield new[0], new[1]
      continue
      if old[0] is None:
        content = new[1]
        continue

      if new[2] == old[2] and new[2] != 'unknown':
        content += ' ' + new[1]
        continue

      if new[0] is None:
        yield (old[0], content)
        break

      if new[2] != old[2] or new[2] == 'unknown' or old[2] == 'unknown':
        yield (old[0], content)
        content = new[1]


def utt_lens():

    mapper = defaultdict(list)

    for (year, utt) in list(speechy()):
      utt_len = len(utt.split())
      if utt_len < 50:
        # print(f'Skipping one-word utterance in year {year}: "{utt}"')
        continue
      if utt_len > 1000:
        # print(f'Skipping very long utterance in year {year}: "{utt}..." ({utt_len} words)')
        continue
      mapper[year].append(utt_len)

    mins = {year: min(lengths) for year, lengths in mapper.items()}
    maxs = {year: max(lengths) for year, lengths in mapper.items()}
    avgs = {year: sum(lengths)/len(lengths) for year, lengths in mapper.items()}
    stds = {year: (sum((l - avgs[year])**2 for l in lengths)/len(lengths))**0.5 for year, lengths in mapper.items()}
    sdt1 = {year: avgs[year] + stds[year] for year in mapper.keys()}
    sdt2 = {year: avgs[year] - stds[year] for year in mapper.keys()}
    return sorted(avgs.items()), sorted(mins.items()), sorted(maxs.items()), sorted(sdt1.items()), sorted(sdt2.items())


avgs, mins, maxs, std1, std2 = utt_lens()
avgl, r = make_line(avgs, 'mean')
minl, r = make_line(mins, 'mins')
maxl, r = make_line(maxs, 'max')
st1l, r = make_line(std1, 'std+1')
st2l, r = make_line(std2, 'std-1')


pyo.iplot({'data' : [avgl, minl, maxl, st1l, st2l],
            'layout':{
                'title':{
                    'text': 'Number of speakers per year',
                    'xanchor': 'center',
                    'x':0.5
                }, }})
```

```{python}
import pandas as pd


def make_lark():
  lark = defaultdict(int)
  yc = defaultdict(int)

  for yr, utt in speechy():
    utt_len = len(utt.split())
    lark[(yr, utt_len)] += 1



  for (yr, utt_len), count in lark.items():
    yield {'x':yr, 'y':utt_len, 'z':count}

df = pd.DataFrame.from_records(list(make_lark()))
```

```{python}
import plotly.express as px
fig = px.density_heatmap(df, x="x", y="y", marginal_x="histogram", marginal_y="histogram")
fig.show()
```

```{python}
from collections import defaultdict

def speakers():
  with sqlite3.connect(tmp_db) as conn:
    cur = conn.cursor()

    mapper = defaultdict(int)

    for (year_old, who_old), (year_new, who_new) in pairwise([(None, None)] + list(cur.execute('select year, who from utterance group by year, id order by date').fetchall())):
      if who_old != who_new or year_old != year_new:
        mapper[year_new] += 1

  return sorted(mapper.items())



line, r = make_line(speakers(), 'total')

pyo.iplot({'data' : [line,],
            'layout':{
                'title':{
                    'text': 'Number of speakers per year',
                    'xanchor': 'center',
                    'x':0.5
                }, }})
```

